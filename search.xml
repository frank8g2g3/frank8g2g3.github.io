<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一次JPA 内存泄露问题排查]]></title>
    <url>%2F2023%2F12%2F13%2F%E4%B8%80%E6%AC%A1JPA-%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[机器：2C4G 程序：用户同步程序 现象：2023.9.15～2023.9.18之间，只要启动全量同步，10分钟内就会发生内存泄漏 排查： 1.代码查看。经查看，代码有Map引用，用于数据比较，使用后并清除，正常 2.线程排查。经查看，线程只启动了3个同步线程，线程正常范围 3.使用jmap 查看内存分布 jmap -histo:live 16372 &gt; 16372.txt 主要对象是hashMap\$Node和org.hibernate.hql.internal.ast.tree.Node 4.使用jmap把内存dump下来分析 jmap -dump:format=b,file=/tmp/memory_dump.hprof 16372 可以看出来主要对象是org.hibernate.internal.SessionFactoryImpl，占用已超2G org.hibernate.engine.query.spi.QueryPlanCache 5.分析 从内存分布和内存快照来看，基本上可以确定，溢出原因就是org.hibernate.internal.SessionFactoryImpl这个类中的org.hibernate.engine.query.spi.QueryPlanCache导致 查阅相关文档， hibernate有缓存机制，主要是QueryPlanCache。查询执行过程中会先去queryPlanCache中获取，如果没有才会去查询库，然后查询和结果值放queryPlanCache中。 在queryPlanCache中由org.hibernate.internal.util.collections.BoundedConcurrentHashMap实现，capacity默认为2048，也就是缓存最大查询计划数为2048，那只需要把capacity这个缓存查询数变小即可 6.修复和运行查看 把程序配置上加上以下配置后再运行 spring.jpa.properties.hibernate.query.plan_cache_max_size=512 spring.jpa.properties.hibernate.query.plan_parameter_metadata_max_size=32 结果如下图，也无内存溢出 本文地址 https://www.frank8g2g3.cn/2023/12/13/一次JPA-内存泄露问题排查/]]></content>
  </entry>
  <entry>
    <title><![CDATA[分析解决问题思维]]></title>
    <url>%2F2020%2F02%2F01%2F%E5%88%86%E6%9E%90%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657分析解决问题 什么是问题 期望与现状的落差部分 某件事的期望值是（B），现状是（B’），（B&apos;→ B）这个落差部分，就是问题 如何描述一个问题 1、明确期望值（B） 你的目标是什么？正常的情况应该是如何的？这个目标是可衡量的吗 2、精准定位现状（B’） 注意区分事实与观点 事实 客观存在 观点 个人感受 描述现状的时候，用大量的「事实」来构筑，而不是「观点」 3、用（B&apos;→ B）这个落差，精准描述问题 不要再问出类似于「你的业绩那么差，打算怎么办？」这样模糊的问题 应该问：你之前三个月的业绩分别是100万，110万，105万，而这个月变成了80万，我们来讨论一下，下个月如何能做到120万？ 如何寻找答案 区分表面问题和本质问题 表面问题（症状） 表面问题，只是由本质问题导致的症状 本质问题 A：为了实现（B）的结果，所使用的方法。如果方法是错误的，目标自然无法达到 B：期望值。目标设置不当，或者目标设定过高，那么即便完美做到了A，这个目标也无法达成 C：过程中出现的变量。方法和目标都没有问题，可是出现了意料之外的事，也有可能导致目标无法达成 （B’）只是症状，而导致这个症状出现的是ABC这三个因素，他们才是更本质的问题 透析三棱镜 校准目标 目标不对，什么都不对 设立目标的SMART原则 Specific，明确的，具体的 Measurable，可衡量的 Achievable，（自力）可达到的 Rewarding，完成后有满足感的 Time-bound，有时间限制的 目标符合SMART原则，避免把手段当成目标 区分目标和手段 目标通常是指行为主体根据自身的需要，预先设想的行为目标和结果 手段指的是为实现某种目的采取的方法、措施 重构方法 方法（A）是你为了实现（B）所用的方法。（这个方法包括了与之相关的人、事、物），现状（B&apos;）不会平白无辜的出现，而是由原来的解决方案（A）导致的。 重复原有的方法，只能得到同样的结果；想要有不同的结果，就需要用不同的方法。如果不改变原有的解决方案，现状就很难改变。 消除变量 如果（A、B）都没有问题了，（B’）还是存在，那么就一定出现了变量（C） [象数理]思考框架 任何一个「现象」背后一定有「数据」，任何「数据」的变动，背后一定有「道理」 当你发现某个现象后，去找相关的数据，然后用「数据」来说明问题，这可以让你对事情从感性认知变成理性分析 把现象背后的数据分解的越细，看到的问题就会越精准 如何找到数据背后的原因 「5Why提问法」 连续追问5个为什么，来寻找这个数据异动背后的原因（5只是一个象征性的数字，意在提醒你，别拿到第一个答案后就认为是全部，而要继续往下深挖） 发现根本原因后，改善行动落实在「自己可以改变」的事情上 总结 在一秒钟内看到本质的人，和花半辈子也看不清一件事本质的人，自然是不一样的命运 本文地址 https://www.frank8g2g3.cn/2020/02/01/分析解决问题思维/]]></content>
  </entry>
  <entry>
    <title><![CDATA[mysql基础知识]]></title>
    <url>%2F2019%2F12%2F15%2Fmysql%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[前段时间整理了mysql相关知识，对其中的知识点进行了梳理和总结，分享出来，希望对大家有所帮助 本文地址 https://www.frank8g2g3.cn/2019/12/15/mysql基础知识/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm自动内存管理机制]]></title>
    <url>%2F2019%2F08%2F30%2Fjvm%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[本文地址 https://www.frank8g2g3.cn/2019/08/30/jvm自动内存管理机制/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm如何加载java类]]></title>
    <url>%2F2019%2F08%2F28%2Fjvm%E5%A6%82%E4%BD%95%E5%8A%A0%E8%BD%BDjava%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[java类型 基本类型（8种基本类型） 引用类型 类（有字节流） 接口（有字节流） 数组（jmv直接生成，无字节流） 类加载过程 加载（查找字节流，创建类的过程） 加载器：启动器加载器、扩展器加载器、应用加载器 加载过程：双亲委派 链接（将创建的类合并至jvm中，使之能执行的过程） 验证（确保符合jvm规范） 准备（为被加载类的静态字段分配内存） 解析（将符号引用解析为实际引用，非必须） 初使化（为标记的常量值字段赋值和执行&lt; clinit &gt;方法的过程） 当虚拟机启动时，初始化用户指定的主类 新建目标类实例的new指令时，初始化 new 指令的目标类 调用静态方法的指令时，初始化该静态方法所在的类 访问静态字段的指令时，初始化该静态字段所在的类 子类的初始化会触发父类的初始化 接口定义了default方法，实现该接口的类的初始化，会触发该接口的初始化 使用反射 API 对某个类进行反射调用时，初始化这个类 初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类 本文地址 https://www.frank8g2g3.cn/2019/08/28/jvm如何加载java类/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java代码运行过程]]></title>
    <url>%2F2019%2F08%2F28%2Fjava%E4%BB%A3%E7%A0%81%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java 代码首先需要将它编译而成的 class 文件加载到jvm中，载后的 Java 类会被存放于方法区（Method Area），实际运行时，虚拟机会执行方法区内的代码。 每当调用进入一个 Java 方法，Java 虚拟机会在当前线的 Java 方法栈中生成一个栈帧，用以存放局部变量以及字节码的操作数.当退出当前执行的方法时，不管是正常返回还是异常返回，jvm均会弹出当前线程的当前栈帧，并将之舍弃。 字节码无法直接执行，jvm会将字节码翻译成机器码，在HotSpot里，有两种形式： 第一种是解释执行，即逐条将字节码翻译成机器码并执行； 第二种是即时编译（Just-In-Time compile，JIT），即将一个方法中包含的所有字节码编译成机器码后再执行. 解释执行优势在于无需等待编译，即时编译在于实际运行快。hotspot默认采用混合模式，先解释执行字节码，而后将反复执行的热点代码，以方法为单位进行即时编译。 本文地址 https://www.frank8g2g3.cn/2019/08/28/java代码运行过程/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[沟通金字塔：怎样才能跟别人好好说话？]]></title>
    <url>%2F2019%2F08%2F28%2F%E6%B2%9F%E9%80%9A%E9%87%91%E5%AD%97%E5%A1%94%2F</url>
    <content type="text"><![CDATA[– 摘自某网硅谷创业之父 Paul Graham，在一篇文章 How to disagree 中，提出过一个经典的「反驳金字塔」（Hierarchy of Disagree）： 什么意思呢？在我们日常生活中，充斥着各种各样的对话，争议，讨论和反驳。Paul Graham 把这些讨论，自下而上，从最低级到最高级，依次分成 7 大类。他指出： 第 1 级到第 3 级：属于「完全无意义」的对话，不需要为它们浪费任何时间和精力。 第 4 级到第 5 级：开始有一定的建设性了，属于「正常的对话」。稍微好一些，值得聆听，但还不够好。 第 6 级到第 7 级：这种才是「有效的讨论」，是真的在交换意见，有含金量，值得认真对待。可惜的是，我们所遇到的大多数人，都不具备「有效讨论」的能力。用 Paul Graham 的话来说，还处于低级和中级的阶段，鲜少有人能抵达高级。类似这样的言论，你一定不会陌生：「只有我一个人觉得你说得不对吗？」「懒得跟你多说，你开心就好。」「这不用想都知道是胡扯，怎么可能嘛。」甚至，无论你说什么，对方总是油盐不进，只会翻来覆去用一句「不对」「我觉得不是这样的」来搪塞……遇到这种情况，你一定只会感到无奈又窝火。我把这样的人，称为「表达欲过剩」。他们往往说话不过脑子，不会考虑「什么东西是有价值的」「什么内容是无意义的」，只顾着自己单方面的表达和宣泄，完全没有「交流」的意识。这其实是一种逻辑能力和思辨能力的欠缺。他们没有意识到，这样做，除了制造垃圾信息，破坏别人的心情，没有任何意义。那么，如何应对这样的人呢？我效仿 Paul Graham，提出了一个本土化的「反驳金字塔」—— 为了以示区别，暂且将其称为「沟通金字塔」。下次遇到这样的人，你就可以对他说：你的表达还处于第一级，非常初级，不具备有效讨论和对话的能力，请再接再厉，争取早日升级到更高阶段，加油！请务必带着微笑，用鼓励的语气对他说，让他感受到你的关怀和勉励。另一方面，也算是一个小小的鞭策：希望你，我，每一个看到文章的人，都能用更高的标准要求自己，尽量「有效地交流」。毕竟，生命这么短，不要让「杠精」影响自己的心情，更不要让自己变成「杠精」。 下面，一起来看看这个 L 版的「沟通金字塔」吧。 这是整体的概览。下面四级都属于「无效的沟通」，只有上面三级，才是有效的讨论。下面，我会详细解释每一个层级。 1. 因人废言在网上，经常能看到这样的回复：5毛拿好，不送。发帖辛苦了，一个帖子多少钱？你洗地洗得还真是够卖力的。像这种方式，从基础上质疑对方的合理性，动摇对方观点的根基 —— 这就是一种「因人废言」：不肯正面面对对方的观点，而是将炮火引向「人」身上，对对方进行人身攻击。这是最低的层级，因为这样做的人，压根就不是想沟通，而是单纯逞口舌之快。具体来说，有两种情况：一种是诉诸人身，如辱骂对方「脑残」「SB」，从言语上贬损对方。这是没有素质的表现，不用说了。另一种是诉诸动机，质疑对方有利益相关，或者立场偏倚，也就是常说的「诛心之论」。比如：给对方贴上「某某粉」「某某派」的标签，进行立场攻击；质疑对方有利益牵涉，如收钱、水军、为自己的生意张目，来否定对方的言论；用带有感情色彩的词语丑化对方，如「上蹿下跳」「跳梁小丑」，等等，贬损对方人格；……它的问题在哪里呢？其实，对方是什么样的人，跟对方的观点是否正确，这两者有任何关系吗？完全没有。但这样做的人，要么忽略了这一点，要么企图让旁观者忽略这一点。仿佛给对方贴上标签，打上某个带有负面色彩的标记，自己就站在了道德的制高点，就已经掌握了胜利。下次看到有人这样做，不妨想一想：如果对方说的真的没有道理，他要么可以置之不理，要么可以直接驳斥，为什么要进行人身攻击呢？这样做，只能暴露出他自己的露怯和无理。 2. 无由反对这是许多人非常容易犯的毛病。什么叫无由反对呢？翻译过来就是：我觉得你说得不对，虽然我也不知道为什么，但我就是要反对你。是不是觉得很无理取闹？但生活中，这种现象十分常见。最根本的原因，就是固化思维：我的心中已经有了许多根深蒂固的「信念」，只要你的话跟这些信念不一致，那就是错的，我要反对你。举个例子：前阵子有人跟我说，现在的95后越来越难管了，前不久才有个员工当面对他说：我不想加班。他一听就生气了，当面斥责员工：你怎么这么计较呢？一点吃苦和投入的精神都没有？问题在于：这个人，是一路加班加过来的，对他来说，加班早已经是一种常态，跟「工作认真投入」牢牢绑定。他不会意识到：别人并不会这样想，不会觉得加班是一件「正确」的事情。他不会去思考：为什么要加班？有什么事一定要加班才能完成？为什么不能提高效率、节约时间？员工的诉求，有没有他的合理之处？所以，我经常说：我们的经验，有时也会制约我们 —— 它会束缚我们的视野，让我们难以挣脱惯性路径，跳出框架去思考问题。怎么破解这一点呢？其实非常简单。下意识地反问一句「为什么」就行。很多我们觉得理所当然的信念，真的就那么理所当然、毋庸置疑吗？不一定。如果你反问一句「为什么」，你也许会发现，很多东西未必站得住脚，只是你一直这样认为而已。如果说因人废言是「回避问题」，那么无由反对，就是「排斥问题」。如果你碰到这样的人，你就应该知道：问题很可能出在他的「固化信念」上面。如果不破除他的固化信念，你们是没办法进行沟通的。 3. 断章取义断章取义，是一种攻击性的反驳。它的模式就是：虽然我也说不出个大概，但是我觉得你说得不对，我要挑挑你的毛病。问题在于：它挑毛病还挑得不准……要么，就是没有击中核心，打到了次要的地方；要么，就是曲解了原意，自己立了一个稻草人在打靶子。举个例子：A：社保新政会提高企业税负成本，虽然到手的钱多了，但最终还是会转嫁到员工身上。B：难道让企业继续剥削员工才好？这就是一种断章取义。A的意思是「社保新政长期来看对员工可能有负面影响」，他想表达的观点，可能是批评政策激进，可能是希望出台其他补助方法，可能是单纯表示忧虑。但B直接把A的观点，曲解成「希望企业继续剥削员工」，就是自己立了一个稻草人。这是很多自媒体惯用的手法。想表达一个观点，又缺乏气势和说服力，怎么办？把观点包装成「反驳」。找一个似是而非的案例，树一个供自己打的靶子，保证每一击都正中核心。从读者的角度看来，自然就会觉得很有说服力。同样，争论时，说不过对方，就有意无意曲解对方的原意，把话题拉到自己熟悉的领域 —— 这也是很常见的伎俩。再比如：A：国外很多大学都是宽进严出，国内也应该效仿，这样才能激励大学生好好学习。B：国外的东西又不是样样都好，为什么一定要学人家？这也是一种断章取义。A的观点，重点在于「宽进严出」，而不在国外；B的攻击，完全跑偏了方向，对主旨无关紧要。当然，比起前两种情况，断章取义还是要好一点，因为它毕竟开始「讨论」问题了。但它远远算不上「有效」，因为它对于问题的讨论和解决，并不能起到任何作用。本质上，仍旧只是争个口头输赢而已。 4. 简单立论简单立论，跟前三种情况相比，最大的区别在于：它不仅仅在于反驳，而能够提出自己的主张。因此，它属于「立论」，而不是「驳论」。但是，它得出主张的推理过程，是粗糙、直觉的，因此并不具备说服力，只是起到了「把自己的观点讲清楚」的作用而已。究其原因，就在于：它将「普遍」和「特殊」混淆了。要么，是以特殊个例来推断普遍情况；要么，是用普遍情况去推断特殊个例。举个例子：很多人喜欢用「故事」来论理，但故事真的能作为论据吗？比如：该进大公司还是小公司？当然是进大公司。我有个朋友，毕业后进了某某大公司，现在已经年薪百万了；企业该对员工狠一点还是松一点？当然是狠一点。我有个朋友，开了一家公司，不考勤、不给员工压力，现在已经倒闭了；在一个家庭中，女性究竟应该顾家，还是要有自己的事业？我有个朋友，她……（编不下去了）它们能够作为论据支撑观点吗？当然不行。像这几个例子，无论正面反面，只要你去找，总能找出一大堆实例。你所看到的，只是别人故意筛选出来，给你看到的而已。要使立论有效，还必须说明： 这些结果真的是由这些原因导致的吗？ 这些结果没有受到别的因素影响吗？ 这些结果对其他人的情况也适用吗？能回答这三个问题，这个立论才算是站得住脚。所以，我从来不看「故事」。因为它并不能真的告诉你什么道理，而只能把作者已经默认的「道理」，讲得更动听些罢了。说到底，这就是一种诉诸个例的修辞手法，而并非论证方式。这是以特殊推断普遍情况，那么，什么是以普遍情况推断特殊呢？一般来说，有这三种情况： 诉诸权威：因为某某专家说转基因有害，所以我拒绝转基因； 诉诸常识：人类干预的东西一定不如天然的好，这不是常识吗； 诉诸群众：朋友圈的文章都说是这么一回事，那就一定是这样。……普遍情况下，权威、常识、群众的理解，有其正确之处。但如果不加思考和辨别，盲目信任他们，无论遇到什么问题，都以「别人的观点」作为圭臬，那就是把思考的权利交给了别人。这也就是「简单立论」，之所以无效的原因。不要让思考停下。 5. 建设性意见从这一级开始，我们终于进入了「有效」的讨论。什么是「建设性意见」？它也是一种反驳，但它的态度是友好、正面的。它并非为了驳倒或击败对方，而是想帮助对方补全论证、完善观点，达到更完备的状态。要么，它能够找到对方论据的错误，进行修正；要么，它能发现对方论点的缺漏，进行修补。像「L先生说」的很多留言，就是「建设性意见」的典范。比如：之前写过一篇文章，讲睡眠的误区，介绍了晨型人和夜型人。文章下有很多朋友留言道：要分清楚自己真的属于夜型人，还是单纯想熬夜。不要拿夜型人来作为自己熬夜的借口。这就是一种「建设性意见」。它没有曲解，没有舍本逐末，本身是正确的，而且因其存在，使得论证更严密、更完整。所以，我经常说：很多文章，其实不仅仅是我的作品，也有读者们的功劳。甚至，有时一条条留言读下来，感觉比读文章本身还有意思。要注意的是：建设性意见，和第六、第七级，并没有截然的高下之分。之所以分成三级，只是因为其程度和完备性不同。当然，也存在态度恶劣、不客气的「建设性意见」，这就是情商和表达方式的问题了。 6. 针对性反驳建设性意见，基于一个前提，那就是双方对主要论点并无太大分歧，只是在局部细节上有不认同之处，因此，进行查漏补缺即可。但如果你不认同对方的主要论点，那就必须提出「针对性反驳」：第一，反对对方论点，并提出自己的论点；第二，用严格的推理和论证，来支撑自己的论点。它和第四级「简单立论」的差别，就在于：你是出于主观臆断，不假思索地提出观点，还是经过深思熟虑，有理有据，采用正确的论证方式。那么，什么是正确的论证方式呢？简单来说，就是两大类：归纳和演绎。前者，是用经得过检验的数据，比如研究结果，调查报告，学术理论，来支撑自己的论点。这些数据怎么来？其实并不难，多读一些严肃的杂志、网站、文章，基本都会有。这也是检验一个信息渠道是否靠谱的特征。靠谱的渠道，会有明确的研究、报告和数据；而不靠谱的渠道，则只会用「我认为」「我身边」「我看到」……来讲故事。那是不是我们平时说话聊天，也不能用「我认为」「我身边」「我看到」？当然也不是。但你要明白，严格来说，这种聊天是算不上论证的，没有说服力。你只能用来表达观点，没办法去说服别人。如果很难找到靠谱的数据，也不要紧，还有另一种方式：用演绎推理，去论证你的观点。举个例子：房价是不会跌的。因为房价跌会引发经济动荡，所以政府会动用一切手段稳定房价。这就是一个（非常朴素的）演绎推理。它是先假定若干个具备共识的前提，再通过因果关系，从前提出发，推出结果，也就是论点。如果你不认同演绎推理的结果，要么，是你不认同它的前提，要么，就是你不认同它的因果关系。无论如何，它总是能够追溯到某个环节的。从数据和前提出发，进行归纳推理或演绎推理，再把多个推理过程组合起来，建立起一整个逻辑链条和结构 —— 这才是有理有据的论证过程。只有这样，提出的观点和反驳，才是有支撑的。 7. 寻求共识第六级「针对性反驳」，其实已经非常完善了。但仍然不是最高级的。为什么呢？因为它的本质，还停留在「反驳」的程度，仍然存在争胜负、分高下的心态。正如我以前写过的：讨论的终极目的，永远不是为了区分胜负，而是为了更接近真相。所以，最高级的思路是什么呢？是把视角往上再提升一个层级，不拘泥于谁对谁错，而是分别找到双方合理的部分，再用一个更高层次的论点去总括，把它们涵盖进来。如同相对论之于经典力学，并不存在谁更正确，本质上只是物理学在高速和低速状态下的不同模型。这就是一个「正-反-合」的过程。做到这一点当然很难，但唯有这样，讨论才会更有价值。它不执着于短期的得失，而是追求双赢。 最后，再一起来复习一下这个金字塔模型。 也希望你我，每一位朋友，能尽量用更高的标准来要求自己，不要成为杠精。 毕竟，律人，须先律己。共勉。: ) 本文地址 https://www.frank8g2g3.cn/2019/08/28/沟通金字塔/]]></content>
      <categories>
        <category>沟通</category>
      </categories>
      <tags>
        <tag>沟通</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基本数据类型]]></title>
    <url>%2F2019%2F04%2F26%2Fjava%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[在jvm规范中，boolean类型被映射成int类型计算，所以在jvm中boolean类型的值可以是0和1之外的值，其他类型也可以。 jvm每调一个方法便会产生一个栈桢，分别是局部变量区，以及字节码的操作数栈。 局部变量区等价于一个数组，long，double值需要用两个数组单元来存储，其他基本类型与引用类型在解释执行的方法栈帧中占用的大小是一致的。但它们在堆中占用的大小确不同。 在存储这些类型字段或者数组单元时，Jvm会进行掩码操作。在读取时，Java虚拟机则会将其扩展为int 类型（堆中加载到操作数栈中,在栈中作为int来处理）。 本文地址 https://www.frank8g2g3.cn/2019/04/26/java基本数据类型/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java进程]]></title>
    <url>%2F2019%2F04%2F21%2Fa%2F</url>
    <content type="text"><![CDATA[查看java进程的线程数 pstree -h pid (查看进程的线程数) top -Hp pid (查看进程中的线程) cat /proc/pid/status (查看进程状态) 查看进程运行时间 ps -p 12841 -o lstart,etime (启动时间，运行时间) java进程内存 jvm内存 ≈ Java永久代 ＋ Java堆(新生代和老年代) ＋ 线程栈内存＋ 堆外内存 jmap jmap -heap pid 查看进程堆内存使用情况，包括使用的GC算法、堆配置参数和各代中堆内存使用情况 jmap -histo:live pid | more 查看堆内存中的对象数目、大小统计直方图，如果带上live则只统计活对象 本文地址 https://www.frank8g2g3.cn/2019/04/21/a/]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
